---
title: "CLL_scRNASeq_alt_filter"
author: "ASG"
date: "7/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## control and treatment cells alternative filtering

Based on the QC metrics of the data (see CLL_scRNASeq_seurat.Rmd, assessing QC metrics section), seems obvious that the two conditions have distinct cell populations based on cell count, transcripts per cell, genes per cell, genes versus UMI counts and complexity. All these metrics are distinct for the two conditions and filtering out cells as proposed in that analysis will filter out close to half the population of cells in the control condition.

In this analysis, we will using different criteria for filtering

## loading needed packages
```{r include=FALSE}
library(Seurat)
library(tidyverse)
library(Matrix)
library(patchwork)
library(RCurl)
library(cowplot)
```


## reading in data
The data provided is in the "data" folder in this project. Consists of 2 sub-folders representing the two conditions. 

```{r}
# load the cll_control data
cll_cntrl_data <- Read10X("./data/control/con1-filtered_feature_bc_matrix/")
# initializing the Seurat object with raw control data
cll_control <- CreateSeuratObject(counts = cll_cntrl_data, project = "cll_cntrl", min.cells = 3, min.features = 200)
cll_control
```

```{r}
# load the cll_treatment data
cll_treat1_data <- Read10X("./data/treat1/treat1-filtered_feature_bc_matrix/")
# initializing the Seurat object with raw treatment data (non-normalized)
cll_treatment <- CreateSeuratObject(counts = cll_treat1_data, project = "cll_treatment", min.cells = 3, min.features = 200)
cll_treatment
```

## Merging both seurat objects, QC visualization and filtering
```{r}
# merging both seurat objects
merged_seurat <- merge(x = cll_control,
                       y = cll_treatment,
                       add.cell.id = c("cntrl", "treat"))
```

## Some data munging
```{r}
# explore merged data
View(merged_seurat@meta.data)
```

there are 3 columns in the current object, we add two additional columns : 
number of genes detected per UMI: this metric gives us an idea of the complexity of our dataset (more genes detected per UMI, more complex our data)
mitochondrial ratio: this metric will give us a percentage of cell reads originating from the mitochondrial genes
```{r}
# add number of genes per UMI
merged_seurat$log10GenesPerUMI <- log10(merged_seurat$nFeature_RNA) /
  log10(merged_seurat$nCount_RNA)
```

```{r}
# add the ratio of mitochondrial genes present
merged_seurat$mitoRatio <- PercentageFeatureSet(object = merged_seurat, pattern = "^MT-")
merged_seurat$mitoRatio <- merged_seurat$mitoRatio / 100
```

### additional metadata columns for convenience
```{r}
# extracting metadata as a dataframe
metadata <- merged_seurat@meta.data
```

adding a new column for cell identifiers

This information is currently located in the row names of our metadata dataframe. We will keep the rownames as is and duplicate it into a new column called cells.
```{r}
# add cell IDs to metadata
metadata$cells <- rownames(metadata)
```

Each cell ID has a cntrl_ or treat_ prefix as we had specified when we merged the Seurat objects. We can use this prefix to create a new column indicating which condition each cell is classified under. We will call this column sample:
```{r}
# create a column called sample
metadata$sample <- NA
metadata$sample[which(str_detect(metadata$cells, "^cntrl_"))] <- "ctrl"
metadata$sample[which(str_detect(metadata$cells, "^treat_"))] <- "treat"
```

rename some of the existing columns in metadata to be more intuitive:
```{r}
# Rename columns
metadata <- metadata %>% 
  rename(seq_folder = orig.ident,
         nUMI = nCount_RNA,
         nGene = nFeature_RNA)
```

### saving new metadata into the merged seurat object
Before we assess our metrics we are going to save all of the work we have done thus far back into our Seurat object. We simply assign the dataframe into the meta.data slot:
```{r}
# add metadata back to the merged seurat object
merged_seurat@meta.data <- metadata

# create a .RData object to load back at any time
# save(merged_seurat, file = "./data/cll_merged_filtered_seurat.RData") # commented out since already saved on macbookair
```


## Cell filtering
Based on above analysis and results from "CLL_separate_analysis_ctrl_treat.Rmd", we will use foll; thresholds:
500> nUMI < 32000, # see reasoning in "CLL_separate_analysis_ctrl_treat.Rmd"
nGene > 300,
mitoRatio < 0.2, # see reasoning in "CLL_separate_analysis_ctrl_treat.Rmd"
log10GeneperUMI > 0.8

```{r}
# filtering out low quality cells based on selected thresholds
filtered_separate_seurat <- subset(x = merged_seurat,
                          subset = (nUMI > 500 &
                                     nUMI < 32000) & 
                            (nGene >= 300) & 
                            (log10GenesPerUMI > 0.8) &
                            (mitoRatio < 0.2))
```

The different filter thresholds create two different filtered seurat objects, we call them "filtered_separate_seurat" and "filtered_seurat" to distinguish them.

## Gene-level filtering

Within our data we will have many genes with zero counts. These genes can dramatically reduce the average expression for a cell and so we will remove them from our data. We will start by identifying which genes have a zero count in each cell:
```{r}
# Extract counts
counts <- GetAssayData(object = filtered_separate_seurat, slot = "counts")

# Output a logical matrix specifying for each gene on whether or not there are more than zero counts per cell
nonzero <- counts > 0
```

Now, we will perform some filtering by prevalence. If a gene is only expressed in a handful of cells, it is not particularly meaningful as it still brings down the averages for all other cells it is not expressed in. For our data we choose to keep only genes which are expressed in 10 or more cells. By using this filter, genes which have zero counts in all cells will effectively be removed.

```{r}
# Sums all TRUE values and returns TRUE if more than 10 TRUE values per gene
keep_genes <- Matrix::rowSums(nonzero) >= 10

# Only keeping those genes expressed in more than 10 cells
filtered_counts <- counts[keep_genes, ]
```

Finally, take those filtered counts and create a new Seurat object for downstream analysis.

```{r}
# Reassign to filtered Seurat object
filtered_separate_seurat <- CreateSeuratObject(filtered_counts, meta.data = filtered_separate_seurat@meta.data)
```


## Reassessing QC metrics
```{r}
# extracting metadata as a dataframe from the filtered_seurat object
separate_filtered_metadata <- filtered_separate_seurat@meta.data
```


```{r}
# Visualize the number of cells in each sample
separate_filtered_metadata %>% 
  ggplot() +
  geom_bar(aes(sample, fill = sample)) +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  ggtitle("NCells_separate")

```
After filtering, the number of ctrl and treated cells is
```{r}
nrow(separate_filtered_metadata %>% filter(sample == "ctrl"))
nrow(separate_filtered_metadata %>% filter(sample == "treat"))
```

```{r}
# visualize the number of transcripts (UMIs) per cell
separate_filtered_metadata %>% 
  ggplot(aes(x = nUMI, color = sample, fill = sample)) +
  geom_density(alpha = 2/10) +
  theme_light() + 
  scale_x_log10() + 
  ylab("cell density") + 
  geom_vline(xintercept = 500) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("transcripts per cell / separate data")
```
```{r}
# visualize number of genes (nGene) per cell with a histogram
separate_filtered_metadata %>% 
  ggplot(aes(nGene, color = sample, fill = sample)) +
  geom_density(alpha = 2/10) + 
  theme_light() + 
  scale_x_log10() + 
  geom_vline(xintercept = 300) + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per cell / separate data")
```
```{r}
# visualize number of genes as a boxplot
separate_filtered_metadata %>% 
  ggplot(aes(x = sample, y = log10(nGene), fill = sample)) + 
  geom_boxplot(alpha = 5/10) + 
  theme_light() + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per cell")
```
```{r}
# scatter plot of UMIs versus genes detected per cell colored by ratio of mitochondrial genes
separate_filtered_metadata %>% 
  ggplot(aes(x = nUMI, y = nGene, color = mitoRatio)) +
  geom_jitter() +
  scale_color_gradient(low = "gray90", high = "black") +
  stat_smooth(method = lm) +
  scale_x_log10() +
  scale_y_log10() +
  theme_light() + 
  geom_vline(xintercept = 2000) +
  geom_hline(yintercept = 400) + 
  facet_wrap(~sample)
```
The horizontal and vertical lines show us the number of cells we lose if we use the mor stringent filtering criteria proposed in the original analysis

```{r}
# visualizing mitochondrial genes per cell 
separate_filtered_metadata %>% 
  ggplot(aes(mitoRatio, color = sample, fill = sample)) + 
  geom_density(alpha = 2/10) + 
  theme_light() + 
  scale_x_log10() + 
  geom_vline(xintercept = 0.2)
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("mitochondrial gene count ratio per cell / separate data")
```

```{r}
# visualizing genes per UMI to assess complexity
separate_filtered_metadata %>% 
  ggplot(aes(log10GenesPerUMI, color = sample, fill = sample)) + 
  geom_density(alpha = 2/10) + 
  theme_light()+
  scale_x_log10() + 
  geom_vline(xintercept = 0.8)
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per UMI / separate data")
```

## Using sctransform

### From the vignette on sctransform from Hafemeister & Satija
Using sctransform in Seurat
Christoph Hafemeister & Rahul Satija

Compiled: 2021-06-14

Source: vignettes/sctransform_vignette.Rmd
Biological heterogeneity in single-cell RNA-seq data is often confounded by technical factors including sequencing depth. The number of molecules detected in each cell can vary significantly between cells, even within the same celltype. Interpretation of scRNA-seq data requires effective pre-processing and normalization to remove this technical variability. In Hafemeister and Satija, 2019 we introduce a modeling framework for the normalization and variance stabilization of molecular count data from scRNA-seq experiment. This procedure omits the need for heuristic steps including pseudocount addition or log-transformation and improves common downstream analytical tasks such as variable gene selection, dimensional reduction, and differential expression.

In this vignette, we demonstrate how using sctransform based normalization enables recovering sharper biological distinction compared to log-normalization.

library(Seurat)
library(ggplot2)
library(sctransform)



### Additional note regarding omitting NormalizeData, ScaleData and FindVariableFeatures functions
Apply sctransform normalization

Note that this single command replaces NormalizeData(), ScaleData(), and FindVariableFeatures().
Transformed data will be available in the SCT assay, which is set as the default after running sctransform
During normalization, we can also remove confounding sources of variation, for example, mitochondrial mapping percentage

### applying sctransform directly to filtered_separate_seurat object

We will apply sctransform directly to the filtered_separate_seurat object without normalizing etc. In earlier analysis, we have determined that cell cycle phase does not have a big effect on PCA, hence we will omit that step. 

We will regress out the mitoRatio factor as done in the "redo" sections of the earlier analysis. This is because, we re-did the entire analysis without regressing out the mitochondrial contribution and found than one cluster amongst 14 (cluster 4 at resolution of 0.8) had only mitochondrial genes in the top 10.

```{r}
# split seurat object by condition for sctransform
split_filtered_seurat_noMito <- SplitObject(filtered_separate_seurat,split.by = "sample")
split_filtered_seurat_noMito <- split_filtered_seurat_noMito[c("ctrl", "treat")]
```

SCTransform can generate large objects in terms of memory, hence adjust the limit for allowable object sizes within R 
```{r}
options(future.globals.maxSize = 4000 * 1024^2)
```

Iterating sctransform over each object in split_filtered_seurat
```{r}
 for (i in seq_along(split_filtered_seurat_noMito)){
  split_filtered_seurat_noMito[[i]] = SCTransform(split_filtered_seurat_noMito[[i]], vars.to.regress = c("mitoRatio")) # regressing out mitochondrial gene ratio as a factor
}
```

checking assays stored in objects
```{r}
split_filtered_seurat_noMito$ctrl@assays
```
```{r}
split_filtered_seurat_noMito$treat@assays
```


## Integration

goal is to integrate across conditions(control and treatment) by aligning similar cell types

### Specifying 3000 most variable genes to be used for integration as identified by sctransform instead of 2000 
```{r}
# select most variable features to be used for integration
integ_features <- SelectIntegrationFeatures(object.list = split_filtered_seurat_noMito,
                                            nfeatures = 3000)
```

### prepare SCTransform object for integration
```{r}
# prepare the SCT list object for integration
split_filtered_seurat_noMito <- PrepSCTIntegration(object.list = split_filtered_seurat_noMito,
                                   anchor.features = integ_features)
```

### perform CCA, find best buddies / anchors, filter incorrect anchors
```{r}
# find best buddies / anchors
integ_anchors <- FindIntegrationAnchors(object.list = split_filtered_seurat_noMito,
                                        normalization.method = "SCT",
                                        anchor.features = integ_features)
```
### Integrate across conditions
```{r}
# integrate across conditions
seurat_filtered_integrated_noMito <- IntegrateData(anchorset = integ_anchors,
                                   normalization.method = "SCT")
```
### Visualizing the integrated data with PCA
```{r}
# PCA
seurat_filtered_integrated_noMito <- RunPCA(object = seurat_filtered_integrated_noMito)

```
```{r}
# plot PCA
PCAPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample")
```

### Visualizing with UMAP
```{r}
# run UMAP
seurat_filtered_integrated_noMito <- RunUMAP(seurat_filtered_integrated_noMito,
                             dims = 1:40,
                             reduction = "pca")
```

```{r}
# plot UMAP
DimPlot(seurat_filtered_integrated_noMito)

```
```{r}
#visualizing side by side with UMAP
DimPlot(seurat_filtered_integrated_noMito,
        split.by = "sample")
```
### Saving the integrated seurat object in results
```{r}
# save integrated seurat object
# saveRDS(seurat_filtered_integrated_noMito, "./results/integrated_filtered_seurat_noMito.rds") # saved in macbookair
```

## Clustering
### Determining number of PCs to use
```{r}
# elbow / scree plot
ElbowPlot(seurat_filtered_integrated_noMito,
          ndims = 50)
```
We will use 50 PCs to determine clusters

### k-nearest neighbors, clusters at various resolutions
```{r}
# K-nearest neighbors graph
seurat_filtered_integrated_noMito <- FindNeighbors(object = seurat_filtered_integrated_noMito,
                                   dims = 1:50)

#determine clusters at various resolutions
seurat_filtered_integrated_noMito <- FindClusters(object = seurat_filtered_integrated_noMito,
                                  resolution = c(0.4, 0.6, 0.8, 1.0, 1.4))
```

### looking at various resolutions
```{r}
seurat_filtered_integrated_noMito@meta.data %>% 
  View()
```

Choosing resolution of 1.4
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.1.4"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 5)
```
Choosing resolution of 1.0
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.1.0"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 5)
```
Choosing resolution of 0.8
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.8"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

Choosing resolution of 0.6
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.6"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

Choosing resolution of 0.2
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.2"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
Choosing resolution of 0.4
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.4"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
Settling on 15 clusters with resolution of 0.8.

Choosing resolution of 0.8
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.8"
```

plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
## QC for Clustering
### Distribution of cells per cluster in each condition
```{r}
# extracting identity and sample information to determine cells per cluster in each condition
n_cells <- FetchData(seurat_filtered_integrated_noMito,
                     vars = c("ident", "orig.ident")) %>% 
  count(ident, orig.ident) %>% 
  spread(ident, n)

n_cells
```

```{r}
# visualizing by count and condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE) +
  NoLegend()
```
### Segregation of clusters by other uninteresting sources of variation
Exploring additional metrics, such as the number of UMIs and genes per cell, S-phase and G2M-phase markers, and mitochondrial gene expression by UMAP. Looking at the individual S and G2M scores can give us additional information to checking the phase as we did previously.
```{r}
# Plot metrics present in seurat_integrated@meta.data
metrics <- c("nUMI", "nGene", "mitoRatio")

FeaturePlot(seurat_filtered_integrated_noMito,
            reduction = "umap",
            features = metrics,
            pt.size = 0.4,
            order = TRUE,
            min.cutoff = "q10",
            label = TRUE)
```

### Exploring PCs that drive different clusters
The hope is that defined PCs separate the cell types well. TO do this, we extract UMAP coordinate information for the cells along with the corresponding scores for each of the first 16 PCs to view by UMAP
```{r}
# defining information of interest in the seurat object
columns <- c(paste0("PC_", 1:16),
             "ident",
             "UMAP_1", "UMAP_2")
# extracting this information from the seurat object
pc_data <- FetchData(seurat_filtered_integrated_noMito, 
                     vars = columns)
```

In the UMAP plots below, cells are colored by their score for each of first 16 PCs
```{r}
# adding cluster label to center of cluster on UMAP
umap_label <- FetchData(seurat_filtered_integrated_noMito,
                        vars = c("ident", "UMAP_1", "UMAP_2")) %>% 
  group_by(ident) %>% 
  summarize(x = mean(UMAP_1), y = mean(UMAP_2))

# plotting a UMAP plot of each of first 16 PCs
map(paste0("PC_", 1:16), function(pc){
  ggplot(pc_data,
         aes(UMAP_1, UMAP_2)) +
    geom_point(aes_string(color = pc),
               alpha = 0.7) + 
    scale_color_gradient(guide = "none",
                         low = "grey90",
                         high = "blue") + 
    geom_text(data = umap_label,
              aes(label = ident, x, y)) + 
    ggtitle(pc)
}) %>% 
  plot_grid(plotlist = .) 
```

Examine PCA results
```{r}
print(seurat_filtered_integrated_noMito[["pca"]], dims = 1:5, nfeatures = 5)
```

### Visualizing cd19 positive cells
```{r}
# select the RNA counts slot to be default assay
DefaultAssay(seurat_filtered_integrated_noMito) <- "RNA"

# Normalize RNA data for visualization
seurat_filtered_integrated_noMito <- NormalizeData(seurat_filtered_integrated_noMito, verbose = FALSE)
```

### Violin plot for CD19 gene
```{r}
# distribution of cd19 marker in clusters
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("CD19"))
```


### Violin plot for CD79A gene
```{r}
# distribution of CD79A B lymphocyte marker in clusters
# info: https://www.ncbi.nlm.nih.gov/gene/973
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("CD79A"))
```

### Violin plot for HLA-DRA gene
```{r}
# distribution of HLA-DRA B lymphocyte marker in clusters
# info: https://www.ncbi.nlm.nih.gov/gene/3122
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("HLA-DRA"))
```
### Violin plot for MS4A1 gene
```{r}
# distribution of MS4A1 B lymphocyte marker in clusters
# info: https://www.ncbi.nlm.nih.gov/gene/931
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("MS4A1"))
```

### Violin plot for CD44 gene
```{r}
# distribution of fibroblast marker in clusters
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("CD44"))
```

## Get conserved markers
```{r}
# ensure default assay is "RNA" for detecting markers
DefaultAssay(seurat_filtered_integrated_noMito) <- "RNA"
```

### Running on all clusters
The FindConservedMarkers function runs on one cluster at a time. We can define a function that will allow us to run it on all clusters in our data
```{r}
# get_conserved function
get_conserved_filtered<- function(cluster){
  FindConservedMarkers(seurat_filtered_integrated_noMito,
                       ident.1 = cluster,
                       grouping.var = "sample",
                       only.pos = TRUE) %>% 
    rownames_to_column(var = "gene") %>% 
    left_join(y = unique(annotations[ , c("gene_name", "description")]),
              by = c("gene" = "gene_name")) %>% 
    cbind(cluster_id = cluster, .)
}
```

Now that we have this function created we can use it as an argument to the appropriate map function. We want the output of the map family of functions to be a dataframe with each cluster output bound together by rows, we will use the map_dfr() function.

```{r}
# iterate function across all clusters
conserved_filtered_markers <- map_dfr(0:14, get_conserved_filtered)
```
## Saving conserved markers
```{r}
# Saving conserved markers object in Results
# saveRDS(conserved_filtered_markers, "./results/conserved_filtered_markers.rds") # saved in macbookair
```

### Evaluating the marker genes to identify clusters

```{r}
# extract top 10 markers per cluster
top10_filtered <- conserved_filtered_markers %>% 
  mutate(avg_fc = (ctrl_avg_log2FC + treat_avg_log2FC) / 2) %>% 
  group_by(cluster_id) %>% 
  top_n(n = 10,
        wt = avg_fc)

View(top10_filtered)
```


## Visualizing top marker from each cluster as a violin plot
```{r}
# top marker from first 7 clusters
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("ACTB", "IGLC1", "NEAT1", "RPL13", "SDF2L1", "MIR210HG", "ATF5"), pt.size = 0.2, ncol = 3 )
```
```{r}
# top marker from last 7 clusters
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("FOSB", "LTB", "ID3", "LGALS1", "NR4A1", "MX1", "SNHG25", "PCLAF"), pt.size = 0.2, ncol = 3 )
```

```{r}
sessionInfo()
```

