---
title: "CLL_scRNASeq_alt_filter"
author: "ASG"
date: "7/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## control and treatment cells alternative filtering

Based on the QC metrics of the data (see CLL_scRNASeq_seurat.Rmd, assessing QC metrics section), seems obvious that the two conditions have distinct cell populations based on cell count, transcripts per cell, genes per cell, genes versus UMI counts and complexity. All these metrics are distinct for the two conditions and filtering out cells as proposed in that analysis will filter out close to half the population of cells in the control condition.

In this analysis, we will using different criteria for filtering

### Genes versus UMIs detected

```{r}
# scatter plot of UMIs versus genes detected per cell colored by ratio of mitochondrial genes
metadata %>% 
  ggplot(aes(x = nUMI, y = nGene, color = mitoRatio)) +
  geom_jitter() +
  scale_color_gradient(low = "gray90", high = "black") +
  stat_smooth(method = lm) +
  scale_x_log10() +
  scale_y_log10() +
  theme_light() + 
  geom_vline(xintercept = 500) +
  geom_hline(yintercept = 300) + 
  facet_wrap(~sample)
```

The horizontal and vertical thresholds proposed above (nGenes and nUMIs resply), will allow few cells with high mitochondrial gene ratio in the treatment condition. We will therefore use a mitochondrial gene ratio threshold of 0.5 for the treated cells and reassess this metric

## Cell filtering
Based on above analysis, we will use foll; thresholds:
nUMI > 500,
nGene > 300,
mitoRatio < 0.3,
log10GeneperUMI > 0.8

```{r}
# filtering out low quality cells based on selected thresholds
filtered_separate_seurat <- subset(x = merged_seurat,
                          subset = (nUMI >= 500) & 
                            (nGene >= 300) & 
                            (log10GenesPerUMI > 0.8) &
                            (mitoRatio < 0.3))
```

The different filter thresholds create two different filtered seurat objects, we call them "filtered_separate_seurat" and "filtered_seurat" to distinguish them.

The more lenient filtering proposed here resulted in eliminating only 16 cells from the data. The more stringent filtering in the other analysis eliminated 420 cells

## Gene-level filtering

Within our data we will have many genes with zero counts. These genes can dramatically reduce the average expression for a cell and so we will remove them from our data. We will start by identifying which genes have a zero count in each cell:
```{r}
# Extract counts
counts <- GetAssayData(object = filtered_separate_seurat, slot = "counts")

# Output a logical matrix specifying for each gene on whether or not there are more than zero counts per cell
nonzero <- counts > 0
```

Now, we will perform some filtering by prevalence. If a gene is only expressed in a handful of cells, it is not particularly meaningful as it still brings down the averages for all other cells it is not expressed in. For our data we choose to keep only genes which are expressed in 10 or more cells. By using this filter, genes which have zero counts in all cells will effectively be removed.

```{r}
# Sums all TRUE values and returns TRUE if more than 10 TRUE values per gene
keep_genes <- Matrix::rowSums(nonzero) >= 10

# Only keeping those genes expressed in more than 10 cells
filtered_counts <- counts[keep_genes, ]
```

Finally, take those filtered counts and create a new Seurat object for downstream analysis.

```{r}
# Reassign to filtered Seurat object
filtered_separate_seurat <- CreateSeuratObject(filtered_counts, meta.data = filtered_separate_seurat@meta.data)
```


## Reassessing QC metrics
```{r}
# extracting metadata as a dataframe from the filtered_seurat object
separate_filtered_metadata <- filtered_separate_seurat@meta.data
```


```{r}
# Visualize the number of cells in each sample
separate_filtered_metadata %>% 
  ggplot() +
  geom_bar(aes(sample, fill = sample)) +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  ggtitle("NCells_separate")

```
After filtering, the number of ctrl and treated cells is
```{r}
nrow(separate_filtered_metadata %>% filter(sample == "ctrl"))
nrow(separate_filtered_metadata %>% filter(sample == "treat"))
```

```{r}
# visualize the number of transcripts (UMIs) per cell
separate_filtered_metadata %>% 
  ggplot(aes(x = nUMI, color = sample, fill = sample)) +
  geom_density(alpha = 2/10) +
  theme_light() + 
  scale_x_log10() + 
  ylab("cell density") + 
  geom_vline(xintercept = 500) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("transcripts per cell / separate data")
```
```{r}
# visualize number of genes (nGene) per cell with a histogram
separate_filtered_metadata %>% 
  ggplot(aes(nGene, color = sample, fill = sample)) +
  geom_density(alpha = 2/10) + 
  theme_light() + 
  scale_x_log10() + 
  geom_vline(xintercept = 300) + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per cell / separate data")
```
```{r}
# visualize number of genes as a boxplot
separate_filtered_metadata %>% 
  ggplot(aes(x = sample, y = log10(nGene), fill = sample)) + 
  geom_boxplot(alpha = 5/10) + 
  theme_light() + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per cell")
```
```{r}
# scatter plot of UMIs versus genes detected per cell colored by ratio of mitochondrial genes
separate_filtered_metadata %>% 
  ggplot(aes(x = nUMI, y = nGene, color = mitoRatio)) +
  geom_jitter() +
  scale_color_gradient(low = "gray90", high = "black") +
  stat_smooth(method = lm) +
  scale_x_log10() +
  scale_y_log10() +
  theme_light() + 
  geom_vline(xintercept = 2000) +
  geom_hline(yintercept = 400) + 
  facet_wrap(~sample)
```
The horizontal and vertical lines show us the number of cells we lose if we use the mor stringent filtering criteria proposed in the original analysis

```{r}
# visualizing mitochondrial genes per cell 
separate_filtered_metadata %>% 
  ggplot(aes(mitoRatio, color = sample, fill = sample)) + 
  geom_density(alpha = 2/10) + 
  theme_light() + 
  scale_x_log10() + 
  geom_vline(xintercept = 0.2)
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("mitochondrial gene count ratio per cell / separate data")
```

```{r}
# visualizing genes per UMI to assess complexity
separate_filtered_metadata %>% 
  ggplot(aes(log10GenesPerUMI, color = sample, fill = sample)) + 
  geom_density(alpha = 2/10) + 
  theme_light()+
  scale_x_log10() + 
  geom_vline(xintercept = 0.8)
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per UMI / separate data")
```

## Using sctransform

### From the vignette on sctransform from Hafemeister & Satija
Using sctransform in Seurat
Christoph Hafemeister & Rahul Satija

Compiled: 2021-06-14

Source: vignettes/sctransform_vignette.Rmd
Biological heterogeneity in single-cell RNA-seq data is often confounded by technical factors including sequencing depth. The number of molecules detected in each cell can vary significantly between cells, even within the same celltype. Interpretation of scRNA-seq data requires effective pre-processing and normalization to remove this technical variability. In Hafemeister and Satija, 2019 we introduce a modeling framework for the normalization and variance stabilization of molecular count data from scRNA-seq experiment. This procedure omits the need for heuristic steps including pseudocount addition or log-transformation and improves common downstream analytical tasks such as variable gene selection, dimensional reduction, and differential expression.

In this vignette, we demonstrate how using sctransform based normalization enables recovering sharper biological distinction compared to log-normalization.

library(Seurat)
library(ggplot2)
library(sctransform)



### Additional note regarding omitting NormalizeData, ScaleData and FindVariableFeatures functions
Apply sctransform normalization

Note that this single command replaces NormalizeData(), ScaleData(), and FindVariableFeatures().
Transformed data will be available in the SCT assay, which is set as the default after running sctransform
During normalization, we can also remove confounding sources of variation, for example, mitochondrial mapping percentage

### applying sctransform directly to filtered_separate_seurat object

We will apply sctransform directly to the filtered_separate_seurat object without normalizing etc. In earlier analysis, we have determined that cell cycle phase does not have a big effect on PCA, hence we will omit that step. 

We will regress out the mitoRatio factor as done in the "redo" sections of the earlier analysis

```{r}
# split seurat object by condition for sctransform
split_filtered_seurat_noMito <- SplitObject(filtered_separate_seurat,split.by = "sample")
split_filtered_seurat_noMito <- split_filtered_seurat_noMito[c("ctrl", "treat")]
```

SCTransform can generate large objects in terms of memory, hence adjust the limit for allowable object sizes within R 
```{r}
options(future.globals.maxSize = 4000 * 1024^2)
```

Iterating sctransform over each object in split_filtered_seurat_noMito
```{r}
 for (i in seq_along(split_filtered_seurat_noMito)){
  split_filtered_seurat_noMito[[i]] = SCTransform(split_filtered_seurat_noMito[[i]], vars.to.regress = c("mitoRatio")) # regressing out mitochondrial gene ratio as a factor
}
```

checking assays stored in objects
```{r}
split_filtered_seurat_noMito$ctrl@assays
```
```{r}
split_filtered_seurat_noMito$treat@assays
```


## Integration after regressing out mitoRatio

goal is to integrate across conditions(control and treatment) by aligning similar cell types

### Specifying 3000 most variable genes to be used for integration as identified by sctransform instead of 2000 
```{r}
# select most variable features to be used for integration
integ_features <- SelectIntegrationFeatures(object.list = split_filtered_seurat_noMito,
                                            nfeatures = 3000)
```

### prepare SCTransform object for integration
```{r}
# prepare the SCT list object for integration
split_filtered_seurat_noMito <- PrepSCTIntegration(object.list = split_filtered_seurat_noMito,
                                   anchor.features = integ_features)
```

### perform CCA, find best buddies / anchors, filter incorrect anchors
```{r}
# find best buddies / anchors
integ_anchors <- FindIntegrationAnchors(object.list = split_filtered_seurat_noMito,
                                        normalization.method = "SCT",
                                        anchor.features = integ_features)
```
### Integrate across conditions
```{r}
# integrate across conditions
seurat_filtered_integrated_noMito <- IntegrateData(anchorset = integ_anchors,
                                   normalization.method = "SCT")
```
### Visualizing the integrated data with PCA
```{r}
# PCA
seurat_filtered_integrated_noMito <- RunPCA(object = seurat_filtered_integrated_noMito)

```
```{r}
# plot PCA
PCAPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample")
```

### Visualizing with UMAP
```{r}
# run UMAP
seurat_filtered_integrated_noMito <- RunUMAP(seurat_filtered_integrated_noMito,
                             dims = 1:40,
                             reduction = "pca")
```

```{r}
# plot UMAP
DimPlot(seurat_filtered_integrated_noMito)

```
```{r}
#visualizing side by side with UMAP
DimPlot(seurat_filtered_integrated_noMito,
        split.by = "sample")
```
### Saving the integrated seurat object in results
```{r}
# save integrated seurat object
# saveRDS(seurat_filtered_integrated_noMito, "./results/integrated_filtered_seurat_noMito.rds") # saved in macbookair
```

## Clustering
### Determining number of PCs to use
```{r}
# elbow / scree plot
ElbowPlot(seurat_filtered_integrated_noMito,
          ndims = 50)
```
We will use 50 PCs to determine clusters

### k-nearest neighbors, clusters at various resolutions
```{r}
# K-nearest neighbors graph
seurat_filtered_integrated_noMito <- FindNeighbors(object = seurat_filtered_integrated_noMito,
                                   dims = 1:50)

#determine clusters at various resolutions
seurat_filtered_integrated_noMito <- FindClusters(object = seurat_filtered_integrated_noMito,
                                  resolution = c(0.4, 0.6, 0.8, 1.0, 1.4))
```

### looking at various resolutions
```{r}
seurat_filtered_integrated_noMito@meta.data %>% 
  View()
```

Choosing resolution of 1.4
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.1.4"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 5)
```
Choosing resolution of 1.0
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.1.0"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 5)
```
Choosing resolution of 0.8
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.8"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

Choosing resolution of 0.6
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.6"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

Choosing resolution of 0.2
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.2"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
Choosing resolution of 0.4
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.4"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_filtered_integrated_noMito,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
Settling on 13 clusters with resolution of 0.6.

Choosing resolution of 0.6
```{r}
# assigning identity of clusters
Idents(object = seurat_filtered_integrated_noMito) <- "integrated_snn_res.0.6"
```

plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
## QC for Clustering
### Distribution of cells per cluster in each condition
```{r}
# extracting identity and sample information to determine cells per cluster in each condition
n_cells <- FetchData(seurat_filtered_integrated_noMito,
                     vars = c("ident", "orig.ident")) %>% 
  count(ident, orig.ident) %>% 
  spread(ident, n)

n_cells
```

```{r}
# visualizing by count and condition
DimPlot(object = seurat_filtered_integrated_noMito,
        split.by = "sample",
        reduction = "umap",
        label = TRUE) +
  NoLegend()
```
### TBD Does cell cycle play a role in clustering

```{r}
# do clusters segregate by cell cycle phase
DimPlot(object = seurat_integrated_noMito,
        label = TRUE,
        split.by = "Phase") + NoLegend()
```
### Does mitochondrial gene content play a role in clustering?
```{r}
# TBD do clusters segregate by mitochondrial gene ratio
DimPlot(object = seurat_filtered_integrated_noMito,
        label = TRUE,
        split.by = "mitoFr") + NoLegend()
```
Plot above shows even distribution of cells with varying fractions of mitochondrial genes indicating they are not a factor in clustering any more.

### Segregation of clusters by other uninteresting sources of variation
Exploring additional metrics, such as the number of UMIs and genes per cell, S-phase and G2M-phase markers, and mitochondrial gene expression by UMAP. Looking at the individual S and G2M scores can give us additional information to checking the phase as we did previously.
```{r}
# Plot metrics present in seurat_integrated_noMito@meta.data
metrics <- c("nUMI", "nGene", "mitoRatio")

FeaturePlot(seurat_filtered_integrated_noMito,
            reduction = "umap",
            features = metrics,
            pt.size = 0.4,
            order = TRUE,
            min.cutoff = "q10",
            label = TRUE)
```

### Exploring PCs that drive different clusters
The hope is that defined PCs separate the cell types well. TO do this, we extract UMAP coordinate information for the cells along with the corresponding scores for each of the first 16 PCs to view by UMAP
```{r}
# defining information of interest in the seurat object
columns <- c(paste0("PC_", 1:16),
             "ident",
             "UMAP_1", "UMAP_2")
# extracting this information from the seurat object
pc_data <- FetchData(seurat_filtered_integrated_noMito, 
                     vars = columns)
```

In the UMAP plots below, cells are colored by their score for each of first 16 PCs
```{r}
# adding cluster label to center of cluster on UMAP
umap_label <- FetchData(seurat_filtered_integrated_noMito,
                        vars = c("ident", "UMAP_1", "UMAP_2")) %>% 
  group_by(ident) %>% 
  summarize(x = mean(UMAP_1), y = mean(UMAP_2))

# plotting a UMAP plot of r each of first 16 PCs
map(paste0("PC_", 1:16), function(pc){
  ggplot(pc_data,
         aes(UMAP_1, UMAP_2)) +
    geom_point(aes_string(color = pc),
               alpha = 0.7) + 
    scale_color_gradient(guide = "none",
                         low = "grey90",
                         high = "blue") + 
    geom_text(data = umap_label,
              aes(label = ident, x, y)) + 
    ggtitle(pc)
}) %>% 
  plot_grid(plotlist = .) 
```

Examine PCA results
```{r}
print(seurat_filtered_integrated_noMito[["pca"]], dims = 1:5, nfeatures = 5)
```

### Visualizing cd19 positive cells
```{r}
# select the RNA counts slot to be default assay
DefaultAssay(seurat_filtered_integrated_noMito) <- "RNA"

# Normalize RNA data for visualization
seurat_filtered_integrated_noMito <- NormalizeData(seurat_filtered_integrated_noMito, verbose = FALSE)
```

### Violin plot for CD19 gene
```{r}
# distribution of cd19 marker in clusters
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("CD19"),
        split.by = "sample")
```


### Violin plot for VPREB3 gene
```{r}
# distribution of VPREB3 marker in clusters
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("VPREB3"),
        split.by = "sample")
```

```{r}
# distribution of top marker in cluster0
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("ACTG1"))
```
```{r}
# distribution of top marker in cluster1
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("RPL13"))
```

```{r}
# distribution of #3 top marker in cluster2
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("FCMR"))
```

```{r}
# distribution of top marker in cluster3
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("IGLC1"))
```
```{r}
# distribution of top marker in cluster4
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("HSPA5"))
```
```{r}
# distribution of top marker in cluster5
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("ATF5"))
```
```{r}
# distribution of top marker in cluster6
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("MIR210HG"))
```

```{r}
# distribution of top marker cluster7
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("FOSB"),
        split.by = "sample")
```
```{r}
# distribution of top marker cluster8
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("LTB"))
```

```{r}
# distribution of top marker cluster9
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("ID3"))
```

```{r}
# distribution of top marker cluster10
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("IRF7"))
```
```{r}
# distribution of top marker cluster11
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("SNHG25"))
```

```{r}
# distribution of top marker cluster12
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("TOP2A"),
        split.by = "sample")
```

*** Clusters 7, 10, 11 and 12 seem unique and 12 is responsive to treatment? TBD***

```{r}
# distribution of fibroblast marker in clusters
VlnPlot(seurat_filtered_integrated_noMito,
        features = c("CD44"))
```

## Get conserved markers
### Running on all clusters
The FindConservedMarkers function runs on one cluster at a time. We can define a function that will allow us to run it on all clusters in our data
```{r}
# get_conserved function
get_conserved_filtered<- function(cluster){
  FindConservedMarkers(seurat_filtered_integrated_noMito,
                       ident.1 = cluster,
                       grouping.var = "sample",
                       only.pos = TRUE) %>% 
    rownames_to_column(var = "gene") %>% 
    left_join(y = unique(annotations[ , c("gene_name", "description")]),
              by = c("gene" = "gene_name")) %>% 
    cbind(cluster_id = cluster, .)
}
```

Now that we have this function created we can use it as an argument to the appropriate map function. We want the output of the map family of functions to be a dataframe with each cluster output bound together by rows, we will use the map_dfr() function.

```{r}
# iterate function across all clusters
conserved_filtered_markers <- map_dfr(0:12, get_conserved_filtered)
```

### Evaluating the marker genes to identify clusters
```{r}
# extract top 10 markers per cluster
top10_filtered <- conserved_filtered_markers %>% 
  mutate(avg_fc = (ctrl_avg_log2FC + treat_avg_log2FC) / 2) %>% 
  group_by(cluster_id) %>% 
  top_n(n = 10,
        wt = avg_fc)

View(top10_filtered)
```

