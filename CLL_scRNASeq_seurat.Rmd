---
title: "CLL_scRNASeq_seurat"
author: "ASG"
date: "7/9/2021"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Chronic lymphocytic leukemia single cell RNA-Seq data in two conditions: control & treatment.

The sample is primary CLL tumor from patient grown under two conditions: control: includes fibroblasts and treatment: includes fibroblasts and growth factor.

Some info on the 10X data from the two conditions can be found:
[link] ~/scRNASeq_SR1/data/control/con1.html and here:[link] ~/scRNASeq_SR1/data/treat1/treat1.html. This includes summary and analysis using Cellranger 6.0.1

## loading needed packages
```{r include=FALSE}
library(Seurat)
library(tidyverse)
library(Matrix)
library(patchwork)
library(RCurl)
library(cowplot)
```

## reading in data
The data provided is in the "data" folder in this project. Consists of 2 sub-folders representing the two conditions. 

```{r}
# load the cll_control data
cll_cntrl_data <- Read10X("./data/control/con1-filtered_feature_bc_matrix/")
# initializing the Seurat object with raw control data
cll_control <- CreateSeuratObject(counts = cll_cntrl_data, project = "cll_cntrl", min.cells = 3, min.features = 200)
cll_control
```

```{r}
# load the cll_treatment data
cll_treat1_data <- Read10X("./data/treat1/treat1-filtered_feature_bc_matrix/")
# initializing the Seurat object with raw treatment data (non-normalized)
cll_treatment <- CreateSeuratObject(counts = cll_treat1_data, project = "cll_treatment", min.cells = 3, min.features = 200)
cll_treatment
```
## QC metrics of "control" data including percent of mitochondrial genes,filtering data & visualizing the metrics

The data provided is a "filtered_feature_bc_matrix". The "raw_feature_bc_matrix" has not been provided. Presumably, this data was filtered by Cellranger and does not need to be refiltered. 

```{r}
# The [[ operator can add columns to object metadata.
cll_control[["percent.mt"]] <- PercentageFeatureSet(cll_control, pattern = "^MT-")
# QC for first 5 cells in control
head(cll_control@meta.data, 5)
```

```{r}
# Visualize QC metrics of control data as a violin plot
VlnPlot(cll_control, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), log = TRUE, ncol = 3)
```
Visually inspecting plots above suggests foll: cutoffs: 
for RNA features: 200 - 3000, for RNA counts: 500 - 10000, for mt gene percentages: upper cut off at 12% 

```{r}
# FeatureScatter : scatter plots of the metrics before filtering

plot1 <- FeatureScatter(cll_control, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(cll_control, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```
filtering based on cutoffs established from violin plots
```{r}
cll_control_filt2x <- subset(cll_control, subset = nFeature_RNA > 200 & nFeature_RNA < 3000 & nCount_RNA < 10000 & percent.mt < 12)
cll_control_filt2x
```
The cll_control & cll_control_filt2x objects differ by 73 cells only (6282 vs 6209).

```{r}
# FeatureScatter : scatter plots of the metrics after filtering

plot1 <- FeatureScatter(cll_control_filt2x, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(cll_control_filt2x, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

## QC metrics of "treatment" data including percent of mitochondrial genes, filtering data & visualizing the metrics
```{r}
# The [[ operator can add columns to object metadata.
cll_treatment[["percent.mt"]] <- PercentageFeatureSet(cll_treatment, pattern = "^MT-")
# QC for first 5 cells in control
head(cll_treatment@meta.data, 5)
```


```{r}
# Visualize QC metrics of treatment data as a violin plot
VlnPlot(cll_treatment, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), log = TRUE, ncol = 3)
```
Visually inspecting the treatment data plots above suggests foll; cutoffs: 
for RNA features: 300 - 5000, for RNA counts: 500 - 30000, for mt gene percentages: upper cutoff at 12% 

```{r}
# FeatureScatter : scatter plots of the metrics before filtering

plot1 <- FeatureScatter(cll_treatment, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(cll_treatment, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

filtering based on cutoffs established from violin plots
```{r}
cll_treatment_filt2x <- subset(cll_treatment, subset = nFeature_RNA > 300 & nFeature_RNA < 5000 & nCount_RNA < 30000 & percent.mt < 12)
```

The cll_treatment & cll_treatment_filt2x objects differ by 116 cells only (4958 vs 4842).
```{r}
# FeatureScatter : scatter plots of the metrics after filtering

plot1 <- FeatureScatter(cll_treatment_filt2x, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(cll_treatment_filt2x, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```
*Instead of doing the refiltering separately on the control an treatment objects, we will merge them and process them together. This assumes, that the two objects are not subject to batch effects*

## Merging both seurat objects, QC visualization and filtering
```{r}
# merging both seurat objects
merged_seurat <- merge(x = cll_control,
                       y = cll_treatment,
                       add.cell.id = c("cntrl", "treat"))
```

## Some data munging
```{r}
# explore merged data
View(merged_seurat@meta.data)
```

there are 3 columns in the current object, we add two additional columns : 
number of genes detected per UMI: this metric gives us an idea of the complexity of our dataset (more genes detected per UMI, more complex our data)
mitochondrial ratio: this metric will give us a percentage of cell reads originating from the mitochondrial genes
```{r}
# add number of genes per UMI
merged_seurat$log10GenesPerUMI <- log10(merged_seurat$nFeature_RNA) /
  log10(merged_seurat$nCount_RNA)
```

```{r}
# add the ratio of mitochondrial genes present
merged_seurat$mitoRatio <- PercentageFeatureSet(object = merged_seurat, pattern = "^MT-")
merged_seurat$mitoRatio <- merged_seurat$mitoRatio / 100
```

### additional metadata columns for convenience
```{r}
# extracting metadata as a dataframe
metadata <- merged_seurat@meta.data
```

adding a new column for cell identifiers

This information is currently located in the row names of our metadata dataframe. We will keep the rownames as is and duplicate it into a new column called cells.
```{r}
# add cell IDs to metadata
metadata$cells <- rownames(metadata)
```

Each cell ID has a cntrl_ or treat_ prefix as we had specified when we merged the Seurat objects. We can use this prefix to create a new column indicating which condition each cell is classified under. We will call this column sample:
```{r}
# create a column called sample
metadata$sample <- NA
metadata$sample[which(str_detect(metadata$cells, "^cntrl_"))] <- "ctrl"
metadata$sample[which(str_detect(metadata$cells, "^treat_"))] <- "treat"
```

rename some of the existing columns in metadata to be more intuitive:
```{r}
# Rename columns
metadata <- metadata %>% 
  rename(seq_folder = orig.ident,
         nUMI = nCount_RNA,
         nGene = nFeature_RNA)
```

### saving new metadata into the merged seurat object
Before we assess our metrics we are going to save all of the work we have done thus far back into our Seurat object. We simply assign the dataframe into the meta.data slot:
```{r}
# add metadata back to the merged seurat object
merged_seurat@meta.data <- metadata

# create a .RData object to load back at any time
# save(merged_seurat, file = "./data/cll_merged_filtered_seurat.RData") # commented out since already saved on macbookair
```

## Assessing QC metrics

### Note from the HBC scRNASeq tutorial:

We will assess various metrics and then decide on which cells are low quality and should be removed from the analysis:

Cell counts
UMI counts per cell
Genes detected per cell
UMIs vs. genes detected
Mitochondrial counts ratio
Novelty

What about doublets? In single-cell RNA sequencing experiments, doublets are generated from two cells. They typically arise due to errors in cell sorting or capture, especially in droplet-based protocols involving thousands of cells. Doublets are obviously undesirable when the aim is to characterize populations at the single-cell level. In particular, they can incorrectly suggest the existence of intermediate populations or transitory states that do not actually exist. Thus, it is desirable to remove doublet libraries so that they do not compromise interpretation of the results.

Why aren’t we checking for doublets? Many workflows use maximum thresholds for UMIs or genes, with the idea that a much higher number of reads or genes detected indicate multiple cells. While this rationale seems to be intuitive, it is not accurate. Also, many of the tools used to detect doublets tend to get rid of cells with intermediate or continuous phenotypes, although they may work well on datasets with very discrete cell types. Scrublet is a popular tool for doublet detection, but we haven’t adequately benchmarked it yet. Currently, we recommend not including any thresholds at this point in time. When we have identified markers for each of the clusters, we suggest exploring the markers to determine whether the markers apply to more than one cell type.

### Cell counts

The cell counts are determined by the number of unique cellular barcodes detected. 

In an ideal world, you would expect the number of unique cellular barcodes to correpsond to the number of cells you loaded. However, this is not the case as capture rates of cells are only a proportion of what is loaded. For example, the inDrops cell capture efficiency is higher (70-80%) compared to 10X which is between 50-60%.

NOTE: The capture efficiency could appear much lower if the cell concentration used for library preparation was not accurate. Cell concentration should NOT be determined by FACS machine or Bioanalyzer (these tools are not accurate for concentration determination), instead use a hemocytometer or automated cell counter for calculation of cell concentration.
The cell numbers can also vary by protocol, producing cell numbers that are much higher than what we loaded. For example, during the inDrops protocol, the cellular barcodes are present in the hydrogels, which are encapsulated in the droplets with a single cell and lysis/reaction mixture. While each hydrogel should have a single cellular barcode associated with it, occasionally a hydrogel can have more than one cellular barcode. Similarly, with the 10X protocol there is a chance of obtaining only a barcoded bead in the emulsion droplet (GEM) and no actual cell. Both of these, in addition to the presence of dying cells can lead to a higher number of cellular barcodes than cells.

```{r}
# Visualize the number of cells in each sample
metadata %>% 
  ggplot() +
  geom_bar(aes(sample, fill = sample)) +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  ggtitle("NCells")

```
### UMI counts (transcripts) per cell

The UMI counts per cell should generally be above 500, that is the low end of what we expect. If UMI counts are between 500-1000 counts, it is usable but the cells probably should have been sequenced more deeply.
```{r}
# visualize the number of transcripts (UMIs) per cell
metadata %>% 
  ggplot(aes(x = nUMI, color = sample, fill = sample)) +
  geom_density(alpha = 2/10) +
  theme_light() + 
  scale_x_log10() + 
  ylab("cell density") + 
  geom_vline(xintercept = 500) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("transcripts per cell")
```
Unless a batch effect, clearly the two populations of cells in the two conditions are distinct, perhaps the "treatment" population exists in the control sample as a small fraction; small peak that appears right below the main peak of "treatment".

### Gene counts per cell

We have similar expectations for gene detection as for UMI detection, although it may be a bit lower than UMIs. For high quality data, the proportional histogram should contain a single large peak that represents cells that were encapsulated. If we see a small shoulder to the left of the major peak (not present in our data), or a bimodal distribution of the cells, that can indicate a couple of things. It might be that there are a set of cells that failed for some reason. It could also be that there are biologically different types of cells (i.e. quiescent cell populations, less complex cells of interest), and/or one type is much smaller than the other (i.e. cells with high counts may be cells that are larger in size). Therefore, this threshold should be assessed with other metrics that we describe in this lesson.
```{r}
# visualize number of genes (nGene) per cell with a histogram
metadata %>% 
  ggplot(aes(nGene, color = sample, fill = sample)) +
  geom_density(alpha = 2/10) + 
  theme_light() + 
  scale_x_log10() + 
  geom_vline(xintercept = 300) + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per cell")
```
```{r}
# visualize number of genes as a boxplot
metadata %>% 
  ggplot(aes(x = sample, y = log10(nGene), fill = sample)) + 
  geom_boxplot(alpha = 5/10) + 
  theme_light() + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per cell")
  
```
Again, we see a distinct second peak in the control condition which is to the *left* of the main peak and superimposed with the "treatment' peak. Perhaps there are secondary peaks in the "treatment" condition also to the *left* of the treatment main peak.

Also, there could be small but distinct peaks to the *right* of both main peaks suggestive of cells that failed or have much fewer genes (fibroblasts?)

### Genes versus UMIs detected

```{r}
# scatter plot of UMIs versus genes detected per cell colored by ratio of mitochondrial genes
metadata %>% 
  ggplot(aes(x = nUMI, y = nGene, color = mitoRatio)) +
  geom_jitter() +
  scale_color_gradient(low = "gray90", high = "black") +
  stat_smooth(method = lm) +
  scale_x_log10() +
  scale_y_log10() +
  theme_light() + 
  geom_vline(xintercept = 2000) +
  geom_hline(yintercept = 400) + 
  facet_wrap(~sample)
```

Here, we have plotted the number of genes versus the number of UMIs colored by the fraction of mitochondrial reads. Mitochondrial read fractions are only high in particularly low count cells with few detected genes (darker colored data points). This could be indicative of damaged/dying cells whose cytoplasmic mRNA has leaked out through a broken membrane, and thus, only mRNA located in the mitochondria is still conserved. These cells are filtered out by our count and gene number thresholds. Jointly visualizing the count and gene thresholds shows the joint filtering effect.

Cells that are poor quality are likely to have low genes and UMIs per cell, and correspond to the data points in the bottom left quadrant of the plot. Good cells will generally exhibit both higher number of genes per cell and higher numbers of UMIs.

### Mitochondrial gene counts

This metric can identify whether there is a large amount of mitochondrial contamination from dead or dying cells.We define poor quality samples for mitochondrial counts as cells which surpass the 0.2 mitochondrial ratio mark, unless of course you are expecting this in your sample.
```{r}
# visualizing mitochondrial genes per cell 
metadata %>% 
  ggplot(aes(mitoRatio, color = sample, fill = sample)) + 
  geom_density(alpha = 2/10) + 
  theme_light() + 
  scale_x_log10() + 
  geom_vline(xintercept = 0.2)
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("mitochondrial gene count ratio per cell")
```

### Complexity

We can evaluate each cell in terms of how complex the RNA species are by using a measure called the novelty score. The novelty score is computed by taking the ratio of nGenes over nUMI. If there are many captured transcripts (high nUMI) and a low number of genes detected in a cell, this likely means that you only captured a low number of genes and simply sequenced transcripts from those lower number of genes over and over again. These low complexity (low novelty) cells could represent a specific cell type (i.e. red blood cells which lack a typical transcriptome), or could be due to some other strange artifact or contamination. Generally, we expect the novelty score to be above 0.80 for good quality cells.
```{r}
# visualizing genes per UMI to assess complexity
metadata %>% 
  ggplot(aes(log10GenesPerUMI, color = sample, fill = sample)) + 
  geom_density(alpha = 2/10) + 
  theme_light()+
  scale_x_log10() + 
  geom_vline(xintercept = 0.8)
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per UMI")
```

## Cell filtering
Based on above analysis, we will use foll; thresholds:
nUMI > 2000,
nGene > 400,
mitoRatio < 0.2,
log10GeneperUMI > 0.8

```{r}
# filtering out low quality cells based on selected thresholds
filtered_seurat <- subset(x = merged_seurat,
                          subset = (nUMI >= 2000) & 
                            (nGene >= 400) & 
                            (log10GenesPerUMI > 0.8) &
                            (mitoRatio < 0.2))
```

## Gene-level filtering

Within our data we will have many genes with zero counts. These genes can dramatically reduce the average expression for a cell and so we will remove them from our data. We will start by identifying which genes have a zero count in each cell:
```{r}
# Extract counts
counts <- GetAssayData(object = filtered_seurat, slot = "counts")

# Output a logical matrix specifying for each gene on whether or not there are more than zero counts per cell
nonzero <- counts > 0
```

Now, we will perform some filtering by prevalence. If a gene is only expressed in a handful of cells, it is not particularly meaningful as it still brings down the averages for all other cells it is not expressed in. For our data we choose to keep only genes which are expressed in 10 or more cells. By using this filter, genes which have zero counts in all cells will effectively be removed.

```{r}
# Sums all TRUE values and returns TRUE if more than 10 TRUE values per gene
keep_genes <- Matrix::rowSums(nonzero) >= 10

# Only keeping those genes expressed in more than 10 cells
filtered_counts <- counts[keep_genes, ]
```

Finally, take those filtered counts and create a new Seurat object for downstream analysis.

```{r}
# Reassign to filtered Seurat object
filtered_seurat <- CreateSeuratObject(filtered_counts, meta.data = filtered_seurat@meta.data)
```

## Reassessing QC metrics
```{r}
# extracting metadata as a dataframe from the filtered_seurat object
filtered_metadata <- filtered_seurat@meta.data
```


```{r}
# Visualize the number of cells in each sample
filtered_metadata %>% 
  ggplot() +
  geom_bar(aes(sample, fill = sample)) +
  theme_light() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  ggtitle("NCells")

```
```{r}
# visualize the number of transcripts (UMIs) per cell
filtered_metadata %>% 
  ggplot(aes(x = nUMI, color = sample, fill = sample)) +
  geom_density(alpha = 2/10) +
  theme_light() + 
  scale_x_log10() + 
  ylab("cell density") + 
  geom_vline(xintercept = 500) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("transcripts per cell")
```
```{r}
# visualize number of genes (nGene) per cell with a histogram
filtered_metadata %>% 
  ggplot(aes(nGene, color = sample, fill = sample)) +
  geom_density(alpha = 2/10) + 
  theme_light() + 
  scale_x_log10() + 
  geom_vline(xintercept = 300) + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per cell")
```
```{r}
# visualize number of genes as a boxplot
filtered_metadata %>% 
  ggplot(aes(x = sample, y = log10(nGene), fill = sample)) + 
  geom_boxplot(alpha = 5/10) + 
  theme_light() + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per cell")
```
```{r}
# scatter plot of UMIs versus genes detected per cell colored by ratio of mitochondrial genes
filtered_metadata %>% 
  ggplot(aes(x = nUMI, y = nGene, color = mitoRatio)) +
  geom_jitter() +
  scale_color_gradient(low = "gray90", high = "black") +
  stat_smooth(method = lm) +
  scale_x_log10() +
  scale_y_log10() +
  theme_light() + 
  geom_vline(xintercept = 2000) +
  geom_hline(yintercept = 400) + 
  facet_wrap(~sample)
```

```{r}
# visualizing mitochondrial genes per cell 
filtered_metadata %>% 
  ggplot(aes(mitoRatio, color = sample, fill = sample)) + 
  geom_density(alpha = 2/10) + 
  theme_light() + 
  scale_x_log10() + 
  geom_vline(xintercept = 0.2)
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("mitochondrial gene count ratio per cell")
```

```{r}
# visualizing genes per UMI to assess complexity
filtered_metadata %>% 
  ggplot(aes(log10GenesPerUMI, color = sample, fill = sample)) + 
  geom_density(alpha = 2/10) + 
  theme_light()+
  scale_x_log10() + 
  geom_vline(xintercept = 0.8)
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) + 
  ggtitle("genes per UMI")
```

## Saving the filtered cells
```{r}
# Create .RData object to load at any time
# save(filtered_seurat, file="./data/seurat_filtered.RData") # commented out since already saved on macbookair
```



## Post QC
### Post QC considerations
The various considerations that will lead to meaningful clustering results can be read here:
https://hbctraining.github.io/scRNA-seq_online/lessons/postQC_workflow.html

The goal of clustering is to separate different cell types into unique clusters of cells. To perform clustering, we determine the genes that are most different in their expression between cells. Then, we use these genes to determine which correlated genes sets are responsible for the largest differences in expression between cells.


### Normalization and regressing out unwanted variation

current packages loaded
```{r}
(.packages())
```
#### Rough normalization before exploring cell cycle effects
```{r}
# Normalize the counts
seurat_phase <- NormalizeData(filtered_seurat)
```
#### Assigning cell cycle phases and scores
To assign each cell a score based on its expression of G2/M and S phase markers, we can use the Seurat function CellCycleScoring(). This function calculates cell cycle phase scores based on canonical markers that required as input.

```{r}
# load cell cycle data; the RData file was downloaded from the seurat github site; the HBC tutorial github data folder does not have any .rda files!
load("./data/cc.genes.updated.2019.rda")

# scoring cells for cell cycle
seurat_phase <- CellCycleScoring(seurat_phase,
                                 s.features = cc.genes.updated.2019$s.genes,
                                 g2m.features = cc.genes.updated.2019$g2m.genes)
```
```{r}
# view cell cycle scores and phases assigned to cells
glimpse(seurat_phase@meta.data)
```

#### Scaling expression data
```{r}
# Identify the most variable genes
seurat_phase <- FindVariableFeatures(seurat_phase,
                                     selection.method = "vst",
                                     nfeatures = 2000,
                                     verbose = FALSE)
# scale the counts
seurat_phase <- ScaleData(seurat_phase)
```
#### PCA and grouping by cell cycle phase
```{r}
# PCA
seurat_phase <- RunPCA(seurat_phase)

# group by cell cycle phase
DimPlot(seurat_phase,
        reduction = "pca",
        group.by = "Phase",
        split.by = "Phase")
```
Based on above plot, we note cell cycle phase has no significant effect. Based on this plot, we would not regress out the variation due to cell cycle.

#### Effects of mitochondrial expression
Mitochondrial expression is another factor which can greatly influence clustering. Oftentimes, it is useful to regress out variation due to mitochondrial expression. However, if the differences in mitochondrial gene expression represent a biological phenomenon that may help to distinguish cell clusters, then we advise not regressing this out. We can perform a quick check similar to looking at cell cycle, but we first can turn the mitochondrial ratio variable into a categorical variable based on quartiles.
```{r}
# check quartile values
summary(seurat_phase@meta.data$mitoRatio)

# turn mitoRatio into a factor vector
seurat_phase@meta.data$mitoFr <- cut(seurat_phase@meta.data$mitoRatio,
                                     breaks = c(-Inf, 0.05498, 0.06675,0.07880, Inf),
                                     labels = c("low", "medium", "medium high", "high"))

#plot the PCA by mitoFr
DimPlot(seurat_phase,
        group.by = "mitoFr",
        split.by = "mitoFr")
```
As a first pass, the mitochondrial gene expression doesn't seem to be a factor in the clusters

#### sctransform normalization and regressing out any unwanted variation

Since we have two samples in our dataset, we want to keep them as separate objects and transform them as that is what is required for integration. We will first split the cells in seurat_phase object into “Control” and “treated”:

```{r}
# split seurat object by condition for sctransform
split_seurat <- SplitObject(seurat_phase,split.by = "sample")
split_seurat <- split_seurat[c("ctrl", "treat")]
```
SCTransform can generate large objects in terms of memory, hence adjust the limit for allowable object sizes within R 
```{r}
options(future.globals.maxSize = 4000 * 1024^2)
```

Iterating sctransform over each object in split_seurat
```{r}
 for (i in seq_along(split_seurat)){
  split_seurat[[i]] = SCTransform(split_seurat[[i]]) # optional vars.to.regress can be set to regress out any unwanted variation e.g. due to cell cycle or mitochondrial gene expression
}
```

checking assays stored in objects
```{r}
split_seurat$ctrl@assays
```
```{r}
split_seurat$treat@assays
```
save the split_seurat object since it took lot of memory and ~ 1 min to generate
```{r}
# saving the sctransform output object
# saveRDS(split_seurat, "./data/split_seurat.rds") # commented out since saved once
```

## Integration

goal is to integrate across conditions(control and treatment) by aligning similar cell types

### Specifying 3000 most variable genes to be used for integration as identified by sctransform instead of 2000 
```{r}
# select most variable features to be used for integration
integ_features <- SelectIntegrationFeatures(object.list = split_seurat,
                                            nfeatures = 3000)
```

### prepare SCTransform object for integration
```{r}
# prepare the SCT list object for integration
split_seurat <- PrepSCTIntegration(object.list = split_seurat,
                                   anchor.features = integ_features)
```
### perform CCA, find best buddies / anchors, filter incorrect anchors
```{r}
# find best buddies / anchors
integ_anchors <- FindIntegrationAnchors(object.list = split_seurat,
                                        normalization.method = "SCT",
                                        anchor.features = integ_features)
```
### Integrate across conditions
```{r}
# integrate across conditions
seurat_integrated <- IntegrateData(anchorset = integ_anchors,
                                   normalization.method = "SCT")
```
### Visualizing the integrated data with PCA
```{r}
# PCA
seurat_integrated <- RunPCA(object = seurat_integrated)

```
```{r}
# plot PCA
PCAPlot(object = seurat_integrated,
        split.by = "sample")
```

### Visualizing with UMAP
```{r}
# run UMAP
seurat_integrated <- RunUMAP(seurat_integrated,
                             dims = 1:40,
                             reduction = "pca")
```
```{r}
# plot UMAP
DimPlot(seurat_integrated)

```
```{r}
#visualizing side by side with UMAP
DimPlot(seurat_integrated,
        split.by = "sample")
```
### Saving the integrated seurat object in results
```{r}
# save integrated seurat object
 # saveRDS(seurat_integrated, "./results/integrated_seurat.rds") # saved n macbookair
```

## Clustering
### Determining number of PCs to use
```{r}
# elbow / scree plot
ElbowPlot(seurat_integrated,
          ndims = 50)
```
We will use 50 PCs to determine clusters

### k-nearest neighbors, clusters at various resolutions
```{r}
# K-nearest neighbors graph
seurat_integrated <- FindNeighbors(object = seurat_integrated,
                                   dims = 1:50)

#determine clusters at various resolutions
seurat_integrated <- FindClusters(object = seurat_integrated,
                                  resolution = c(0.4, 0.6, 0.8, 1.0, 1.4))
```

### looking at various resolutions
```{r}
seurat_integrated@meta.data %>% 
  View()
```

Choosing resolution of 1.4
```{r}
# assigning identity of clusters
Idents(object = seurat_integrated) <- "integrated_snn_res.1.4"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_integrated,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_integrated,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 5)
```
Choosing resolution of 1.0
```{r}
# assigning identity of clusters
Idents(object = seurat_integrated) <- "integrated_snn_res.1.0"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_integrated,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_integrated,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 5)
```
Choosing resolution of 0.8
```{r}
# assigning identity of clusters
Idents(object = seurat_integrated) <- "integrated_snn_res.0.8"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_integrated,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_integrated,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

Choosing resolution of 0.6
```{r}
# assigning identity of clusters
Idents(object = seurat_integrated) <- "integrated_snn_res.0.6"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_integrated,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_integrated,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

Choosing resolution of 0.2
```{r}
# assigning identity of clusters
Idents(object = seurat_integrated) <- "integrated_snn_res.0.2"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_integrated,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_integrated,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
Choosing resolution of 0.4
```{r}
# assigning identity of clusters
Idents(object = seurat_integrated) <- "integrated_snn_res.0.4"
```

We have calculated UMAP earlier, hence we only visualize the clusters
```{r}
# Plot the UMAP
DimPlot(object = seurat_integrated,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
plotting a split UMAP plot
```{r}
# plot UMAP by condition
DimPlot(object = seurat_integrated,
        split.by = "sample",
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```
Settling on 10 clusters with resolution of 0.4.
